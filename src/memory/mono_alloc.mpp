/*
 * File: mono_alloc.mpp
 * Author: kissholic
 * Copyright (c) 2025 kissholic. All wrongs reserved.
 */

export module khbase:memory.mono_alloc;
import std;

import :memory.uninitialized_array;

export namespace kh {

template <std::size_t N, typename T = char>
class mono_allocator {
	constexpr static std::size_t pool_size = N * sizeof(T);

public:
	using allocator_type		= mono_allocator;
	using value_type			= T;
	using pointer				= T*;
	using const_pointer			= const T*;
	using void_pointer			= void*;
	using const_void_pointer	= const void*;
	using difference_type		= std::ptrdiff_t;
	using size_type				= std::size_t;

	mono_allocator() = default;
	~mono_allocator() requires std::is_trivially_destructible_v<T> = default;
	~mono_allocator() requires (!std::is_trivially_destructible_v<T>) {
		std::ranges::destroy_n(m_pool.data(), m_pool.size());
	}

	pointer alloc() {
		auto pos = m_pool.uninitialized_insert(m_pool.end(), 1);
		return pos.operator->();
	}

private:
	uninitialized_array<T, pool_size> m_pool;
};


} // namespace kh
